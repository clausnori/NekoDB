# Документация NekoDB

NekoDB - это легковесная файловая база данных на Python, поддерживающая базовые CRUD-операции, индексирование, ссылочную целостность и валидацию типов. Данные хранятся в JSON-файлах, операции потокобезопасны и поддерживают кэширование.

## Содержание
- [Основные возможности](#основные-возможности)
- [Установка](#установка)
- [Базовое использование](#базовое-использование)
- [Типы данных](#типы-данных)
- [Операции с таблицами](#операции-с-таблицами)
- [Операции с данными](#операции-с-данными)
- [Целостность данных](#целостность-данных)
- [Производительность](#производительность)
- [Импорт/Экспорт](#импортэкспорт)

## Основные возможности

- Хранение данных в JSON-формате
- Потокобезопасные операции с блокировкой на уровне таблиц
- Поддержка индексов для оптимизации запросов
- Обеспечение ссылочной целостности
- Валидация и преобразование типов
- Механизм LRU-кэширования
- Пакетные операции с чтением по частям
- Функциональность импорта/экспорта

## Установка

База данных реализована как один Python-модуль. Требования:
- Python 3.7+
- Только стандартная библиотека (без внешних зависимостей)

## Базовое использование

```python
import NekoDB, QueryCondition

# Инициализация базы данных
db = NekoDB("путь_к_данным", cache_size=10000)

# Создание таблицы
db.create_table("пользователи", {
    "id": {
        "types": ["int", "autoincrement"],
        "nullable": False,
        "unique": True
    },
    "имя": {
        "types": ["str"],
        "nullable": False
    },
    "email": {
        "types": ["str"],
        "unique": True
    }
})

# Вставка данных
db.insert("users", {
    "имя": "Иван Петров",
    "email": "ivan@example.com"
})

# Поиск данных
contains = [QueryCondition("имя", "=", "Иван Петров")]
users = db.find("users", contains)
```

## Типы данных

Поддерживаемые типы данных:
- `int`: Целые числа
- `float`: Числа с плавающей точкой
- `str`: Строковые значения
- `bool`: Логические значения
- `list`: JSON-массивы
- `dict`: JSON-объекты
- `autoincrement`: Специальный тип для автоинкрементных целочисленных полей

## Операции с таблицами

### Создание таблиц

```python
db.create_table("имя_таблицы", {
    "имя_столбца": {
        "types": ["тип1", "тип2"],
        "reference": {"table": "связанная_таблица", "field": "связанное_поле"},
        "indexed": True/False,
        "unique": True/False,
        "nullable": True/False
    }
})
```

1. "nullable": False — указывает, что поле не может содержать NULL значения. Это значит, что при добавлении записи необходимо обязательно задать значение для этого столбца. Если значение не указано, будет выброшена ошибка.


2. "unique": True — указывает, что значения в этом столбце должны быть уникальными. Это означает, что при добавлении новой записи значение в этом поле не должно совпадать ни с одним другим значением в этом же столбце для уже существующих записей.

3. "indexed": True — создаёт индекс для этого поля, что ускоряет поиск записей, сортировку и фильтрацию по этому полю. Индексы полезны для часто используемых полей в поисковых запросах. "indexed": False — для этого поля индекс не создаётся, что экономит место в базе данных, но замедляет поиск по этому полю.


Пример: Если в таблице users задать indexed: True для поля name, поиск по name будет выполняться быстрее:

```python
{
    "id": {"types": ["int"], "unique": True, "nullable": False},
    "name": {"types": ["str"], "unique": False, "nullable": False, "indexed": True},
}
```


### Удаление таблиц

```python
db.drop_table("имя_таблицы")
```

## Операции с данными

### Операции поиска

```python
# Поиск всех записей
note = db.find("имя_таблицы")

# Поиск с условиями
условия = [
    QueryCondition("поле", "=", значение),
    QueryCondition("поле2", ">", значение2)
]
записи = db.find("имя_таблицы", условия, order_by="поле", reverse=True, limit=10)

# Поиск одной записи
запись = db.find_one("имя_таблицы", условия)
```

Поддерживаемые операторы:
- `=`: Равно
- `>`: Больше
- `<`: Меньше
- `>=`: Больше или равно
- `<=`: Меньше или равно
- `!=`: Не равно
- `in`: Значение в списке
- `not in`: Значение не в списке
- `contains`: Строка/список содержит значение
- `startswith`: Строка начинается с значения
- `endswith`: Строка заканчивается значением

### Операции обновления

```python
contains = [QueryCondition("name", "=", "Claus")]
update = {"age": 10}
update_count = db.update("users", contains, update)
```

### Операции удаления

```python
условия = [QueryCondition("поле", "=", значение)]
количество_удаленных = db.delete("имя_таблицы", условия)
```

## Целостность данных

### Ссылочная целостность
- Внешние ключи проверяются при вставке и обновлении
- Удаление связанных записей блокируется
- Ссылки проверяются при создании таблицы

### Валидация типов
- Значения проверяются на соответствие объявленным типам
- Автоматическое преобразование типов где возможно
- Обработка NULL-значений на основе флага nullable

### Уникальные ограничения
- Уникальные ограничения проверяются при вставке и обновлении
- Поддерживается несколько уникальных полей в таблице

## Производительность

### Индексирование
- Индексы могут быть созданы для любого поля
- Автоматическое обновление при вставке/обновлении/удалении
- Автоматическое использование для условий равенства

### Кэширование
- LRU-кэш с настраиваемым размером
- Потокобезопасные операции с кэшем
- Автоматическая инвалидация при обновлениях

### Чтение по частям
- Большие наборы данных читаются частями
- Эффективное использование памяти при итерации
- Настраиваемый размер частей

## Импорт/Экспорт

### Экспорт базы данных
```python
db.export_json("резервная_копия.json")
```

### Импорт базы данных
```python
db.import_json("резервная_копия.json")
```

## Обработка ошибок

База данных реализует комплексную проверку ошибок:
- Проверка существования таблиц
- Проверка существования столбцов
- Проверка типов
- Проверка ссылок
- Проверка уникальных ограничений
- Обработка ошибок файловых операций

Основные ошибки:
- `ValueError`: Некорректные операции или данные
- `RuntimeError`: Ошибки реализации
- `FileNotFoundError`: Отсутствующие файлы данных
- `json.JSONDecodeError`: Поврежденные данные

## Потокобезопасность

База данных обеспечивает потокобезопасность через:
- Блокировки на уровне таблиц для операций записи
- Безопасный доступ к кэшу с отдельной блокировкой
- Атомарные файловые операции
- Использование временных файлов для обновлений

## Лучшие практики

1. Всегда используйте подходящие типы для столбцов
2. Создавайте индексы для часто запрашиваемых полей
3. Используйте транзакции для связанных операций
4. Регулярно делайте резервные копии через export_json
5. Следите за размерами файлов и использованием кэша
6. Правильно обрабатывайте исключения
7. Используйте условия для ограничения размера набора данных
8. Много кофе

## Примеры использования

### Создание связанных таблиц

```python
# Создаем таблицу отделов
db.create_table("отделы", {
    "id": {
        "types": ["int", "autoincrement"],
        "nullable": False,
        "unique": True
    },
    "название": {
        "types": ["str"],
        "nullable": False
    }
})

# Создаем таблицу сотрудников со ссылкой на отдел
db.create_table("сотрудники", {
    "id": {
        "types": ["int", "autoincrement"],
        "nullable": False,
        "unique": True
    },
    "имя": {
        "types": ["str"],
        "nullable": False
    },
    "отдел_id": {
        "types": ["int"],
        "reference": {"table": "отделы", "field": "id"},
        "nullable": False,
        "indexed": True
    }
})
```

### Сложные запросы

```python
# Поиск сотрудников определенного отдела с фильтрацией по имени
условия = [
    QueryCondition("отдел_id", "=", 1),
    QueryCondition("имя", "startswith", "Иван")
]
сотрудники = db.find("сотрудники", условия, order_by="имя")
```